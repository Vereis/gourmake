# Gourmake
Gourmake is an Erlang/OTP application which probabalistically generates new recipes based on recipe templates which encode human knowledge. Gourmake was created for a computational creativity project at University.

Gourmake works by searching several databases of recipes, ingredients, cuisines and ingredient categories to stochastically fill in gaps left in the recipes. Because these databases encode human information about ingredients and cuisines, recipes generated by Gourmake generally look relatively real and human made, though there are of course some exceptions.

## Architecture
Gourmake's main business logic is decentralised across three major processes: 
- The Ingredient Server which acts as a database containing all of the ingredients currently loaded into Gourmake, as well as information about what ingredients are used in certain cuisines and categories.
- The Recipe Server which acts as a database containing all of the recipe templates currently loaded into Gourmake. The recipe server is responsible for choosing recipes to create, as well as communicating with the Ingredient Server to actually create recipes.
- The Name Server which is just responsible for loading in some string prefixes to recipe names which help individualise each invented recipe.

Gourmake's servers are all in-memory databases. The ```main.erl``` module contains bootstrapping logic as well as a means of easily generating and pretty printing recipes into Markdown via ```main:main/0```. Otherwise, it is possible to interact with the servers directly in the Erlang shell.

Each server loads its information at spawn time, files loaded are named according and exist in the ```$PROJECTROOT/data``` directory. The files simply contain stored Erlang terms which are read via Erlang's ```file:consult/1``` function. It's possible to manually load more data into the servers either by updating these files and restarting them, or simply pushing data into the processes through their callbacks which are documented in their individual source code files.

### Recipes
Recipes are defined in the following schema:
```erlang
-type INTERPSTRING()       :: string(). %% String patterns in the form ~INTERPKEY are interpolated
-type CUISINE()            :: atom().
-type INTERPKEY()          :: atom().
-type CATEGORY()           :: atom().
-type CATEGORY_BLACKLIST() :: atom().
-type MIN :: non_neg_integer().
-type MAX :: non_neg_integer().
[
    #{
        name => INTERPSTRING,
        cuisines => [
            CUISINE, ...
        ]
        ingredients => #{
            INTERPKEY => {MIN, MAX, [CATEGORY, ...], [CATEGORY_BLACKLIST, ...]},
            ...
        },
        steps => [
            INTERPSTRING,
            ...
        ]
    },
    ...
]
```

### Ingredients
Ingredients are defined in the following schema:
```erlang
-type NAME()     :: atom(),
-type CATEGORY() :: atom().
-type CUISINE()  :: atom().
[
    {
        NAME,
        #{
            categories => [
                CATEGORY,
                ...
            ],
            cuisines => [
                CUISINE,
                ...
            ]
        }
    },
    ...
]
```
Categories of ingredients, as well as cuisines of ingredients are generated from this file. NAMEs get pretty printed out as space seperated strings.

### Names
Names are simply defined via
```erlang
[
    string(),
    ...
]
```
